/* eslint-disable no-unused-vars,react/sort-comp */
import React from 'react';
import PropTypes from 'prop-types';
import _ from 'lodash/fp';
import { ScrollSync } from 'react-virtualized';
import ContainerDimensions from 'react-container-dimensions';
import scrollbarSize from 'dom-helpers/util/scrollbarSize';
import ErrorBoundary from 'viewManager/common/Components/ErrorBoundary';
import { updateSearchCountArray } from 'store/reducers/pages';

import styles from './VirtualizedTableView.css';
import BodyCellPopover from './BodyCellPopover';
import GroupHeadersGrid from './GroupHeadersGrid';
import HeadersGrid from './HeadersGrid';
import FiltersGrid from './FitlersGrid';
import BodyGrid from './BodyGrid';
import TableHeader from './TableHeader';


class VirtualizedTableView extends React.Component {
  static propTypes = {
    tableName: PropTypes.string,
    cols: PropTypes.arrayOf(PropTypes.any),
    columnCount: PropTypes.number.isRequired,
    rows: PropTypes.oneOfType(
      [
        PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.any)),
        PropTypes.func,
      ]
    ).isRequired,
    rowCount: PropTypes.number,
    totalRowCount: PropTypes.number,
    columnWidth: PropTypes.number,
    rowHeight: PropTypes.number,
    withGroups: PropTypes.bool,
    onSort: PropTypes.func.isRequired,
    onFilter: PropTypes.func.isRequired,
    onCellDoubleClick: PropTypes.func.isRequired,
    sortState: PropTypes.shape(),
    filterState: PropTypes.shape(),
    overrideStyle: PropTypes.func,
    tableHeader: PropTypes.func,
    searchForThisView: PropTypes.bool,
    searching: PropTypes.string,
    onResizeColumn: PropTypes.func.isRequired,
    estimatedColumnsSize: PropTypes.number.isRequired,
    tableRef: PropTypes.func,
    virtualIndex: PropTypes.func,
    selectableRows: PropTypes.bool,
    overscanColumnCount: PropTypes.number,
    overscanRowCount: PropTypes.number,
    headerHeight: PropTypes.number,
    cellContextMenu: PropTypes.func,
  };

  static defaultProps = {
    tableName: 'Data table',
    cols: [],
    rows: [],
    rowCount: 0,
    totalRowCount: 0,
    columnWidth: 220,
    rowHeight: 22,
    bodyCellActions: null,
    withGroups: false,
    sortState: {},
    filterState: {},
    overrideStyle: () => ({}),
    tableHeader: null,
    searchForThisView: false,
    searching: '',
    tableRef: () => {
    },
    virtualIndex: _.identity,
    selectableRows: false,
    overscanColumnCount: 0,
    overscanRowCount: 0,
    headerHeight: 42,
    cellContextMenu: null,
  };

  static _wrapHoveredCell(ev, { content, columnIndex }) {
    return {
      target: ev.target,
      content,
      columnIndex,
    };
  }

  static _isSameContent(a, b) {
    /**
     * Determines if the two specified objects `a` and `b` reference the same data object
     * We use the `rowId` identifier that is generated by the hash function
     * used in `injectTabulerData`.
     *
     * @param a
     * @param b
     * @returns {boolean}
     * @private
     */
    if (typeof a !== 'object' || typeof b !== 'object') {
      return false;
    }

    return a.rowId === b.rowId && a.colKey === b.colKey;
  }

  constructor(props, context) {
    super(props, context);
    const { cols } = props;

    this.state = {
      count: 0,
    };

    this.inputRefs = {};
    cols.forEach((colKey) => {
      this.inputRefs[colKey] = React.createRef();
    });
  }

  componentDidUpdate() {
    ['groupHeadersGrid', 'headersGrid', 'filtersGrid', 'bodyGrid'].forEach((gridKey) => {
      const currentGrid = this[gridKey];
      if (currentGrid) {
        currentGrid.recomputeGridSize();
        currentGrid.measureAllCells();
      }
    });
  }

  _getColumnName = col => col.title;

  _getColumnWidth = ({ index }) => this.props.cols[index].width || this.props.columnWidth;

  _onSectionRendered = ({ columnStopIndex }) => {
    const currentState = _.getOr({}, 'state', this);

    this.setState({
      ...currentState,
      columnStopIndex,
    });
  };

  _onScrollbarPresenceChange = ({ vertical }) => {
    this.setState({
      isVerticalScrollbarDisplayed: vertical,
    });
  };

  _onUpdateFilter = (colKey, newFilterValue) => {
    const { onFilter } = this.props;

    const _deferredOnFilter = () => {
      onFilter(colKey, newFilterValue);
      this.scrollToTop();
    };

    return _.debounce(500, _deferredOnFilter);
  };

  _onSelectRow = (content) => {
    const updatedState = _.set(
      ['selectedRows', content.rowId],
      content,
      this.state
    );

    this.setState(updatedState);
  };

  _onUnselectRow = (content) => {
    const updatedState = _.unset(
      ['selectedRows', content.rowId],
      this.state
    );

    this.setState(updatedState);
  };

  _onToggleRow = (content) => {
    const selectedRows = _.getOr({}, 'selectedRows', this.state);

    if (!_.has(content.rowId, selectedRows)) {
      this._onSelectRow(content);
      return;
    }

    this._onUnselectRow(content);
  };

  _onCellEnter = (ev, { content, columnIndex }) => {
    const hoveredCell = VirtualizedTableView._wrapHoveredCell(ev, { content, columnIndex });
    const updatedState = _.set('hoveredCell', hoveredCell, this.state);

    this.setState(updatedState);
  };

  _onCellLeave = (ev, { content }) => {
    const existingHoveredCell = _.get('hoveredCell', this.state);
    const existingHoveredContent = _.get('content', existingHoveredCell);

    if (VirtualizedTableView._isSameContent(content, existingHoveredContent)) {
      const updatedState = _.set('hoveredCell', null, this.state);
      this.setState(updatedState);
    }
  };

  scrollToRow = (rowIndex) => {
    if (this.bodyGrid) {
      const { totalRowCount } = this.props;

      let rowIndexToScrollTo = rowIndex;

      if (rowIndex > totalRowCount) {
        rowIndexToScrollTo = rowIndex;
      } else {
        const { virtualIndex } = this.props;

        if (typeof virtualIndex === 'function') {
          rowIndexToScrollTo = virtualIndex(rowIndex);
        }
      }

      this.bodyGrid.scrollToCell({ rowIndex: rowIndexToScrollTo });
    }
  };

  scrollToTop = () => {
    if (this.bodyGrid) {
      this.bodyGrid.scrollToCell({ rowIndex: 0 });
    }
  };

  scrollToBottom = () => {
    if (this.bodyGrid) {
      this.bodyGrid.scrollToCell({ rowIndex: 0 });
    }
  };

  getSelectedRows = () => Object.values(_.getOr({}, 'selectedRows', this.state));

  render() {
    const {
      tableRef,
      tableName,
      cols,
      rows,
      rowCount,
      totalRowCount,
      rowHeight,
      withGroups, // choose to display or not groups headers,
                  // in this case, cols objects should have `group` key
                  // WARNING: cols still should be in the right order (by group)
                  // as this component does not reorder them to match groups
      onSort,
      onCellDoubleClick,
      sortState,
      filterState,
      overrideStyle,
      columnCount,
      estimatedColumnsSize,
      tableHeader,
      searching,
      searchForThisView,
      onResizeColumn,
      selectableRows,
      overscanColumnCount,
      overscanRowCount,
      headerHeight,
      cellContextMenu,
    } = this.props;

    const hoveredCell = _.get('hoveredCell', this.state);

    const columnStopIndex = _.get('columnStopIndex', this.state);

    const numberOfColumns = cols.length;

    const extendedRowHeight = rowHeight * 2;

    const _computeAdjustedDimensions = ({ width, height }) => {
      const adjustedWidth =
        Math.min(width - scrollbarSize(), estimatedColumnsSize);

      let adjustedHeight = height - headerHeight - (3 * rowHeight) - scrollbarSize();

      if (withGroups) {
        // take into account the space taken by the additional row
        // used to display group names
        adjustedHeight -= rowHeight;
      }

      return { adjustedWidth, adjustedHeight };
    };

    return (
      <ErrorBoundary>
        <ContainerDimensions>
          {
            ({ width, height }) => {
              const { adjustedWidth, adjustedHeight } =
                _computeAdjustedDimensions({ width, height });

              return (
                <div
                  ref={() => {
                    tableRef(this);
                  }}
                >
                  <TableHeader
                    totalRowCount={totalRowCount}
                    rowCount={rowCount}
                    tableName={tableName}
                    tableHeader={tableHeader}
                  />
                  <ScrollSync className={styles.container}>
                    {
                      ({ onScroll, scrollLeft, scrollTop }) => (
                        <div className={styles.GridRow}>
                          <BodyCellPopover
                            parent={this}
                            hoveredCell={hoveredCell}
                            columnStopIndex={columnStopIndex}
                            numberOfColumns={numberOfColumns}
                          />
                          <div className={styles.GridColumn}>
                            <GroupHeadersGrid
                              gridRef={(node) => {
                                this.groupHeadersGrid = node;
                              }}
                              overscanColumnCount={overscanColumnCount}
                              columnName={this._getColumnName}
                              estimatedColumnsSize={estimatedColumnsSize}
                              scrollTop={scrollTop}
                              width={adjustedWidth}
                              cols={cols}
                              onResizeColumn={onResizeColumn}
                              show={withGroups}
                              columnWidth={this._getColumnWidth}
                              columnCount={columnCount}
                              rowHeight={rowHeight}
                              scrollLeft={scrollLeft}
                            />
                            <HeadersGrid
                              gridRef={(node) => {
                                this.headersGrid = node;
                              }}
                              columnWidth={this._getColumnWidth}
                              height={extendedRowHeight}
                              rowHeight={extendedRowHeight}
                              onResizeColumn={onResizeColumn}
                              width={adjustedWidth}
                              cols={cols}
                              sortState={sortState}
                              overscanColumnCount={overscanColumnCount}
                              onSort={onSort}
                              withGroups={withGroups}
                              scrollTop={scrollTop}
                              estimatedColumnsSize={estimatedColumnsSize}
                              columnCount={columnCount}
                              columnName={this._getColumnName}
                              scrollLeft={scrollLeft}
                              scrollToTop={this.scrollToTop}
                            />
                            <FiltersGrid
                              gridRef={(node) => {
                                this.filtersGrid = node;
                              }}
                              inputRefs={(node, colKey) => {
                                this.inputRefs[colKey] = node;
                              }}
                              overscanColumnCount={overscanColumnCount}
                              columnCount={columnCount}
                              width={adjustedWidth}
                              estimatedColumnsSize={estimatedColumnsSize}
                              columnWidth={this._getColumnWidth}
                              height={rowHeight}
                              scrollTop={scrollTop}
                              cols={cols}
                              filterState={filterState}
                              scrollLeft={scrollLeft}
                              onUpdateFilter={this._onUpdateFilter}
                            />
                            <BodyGrid
                              gridRef={(node) => {
                                this.bodyGrid = node;
                              }}
                              searchForThisView={searchForThisView}
                              overscanRowCount={overscanRowCount}
                              rowHeight={rowHeight}
                              columnWidth={this._getColumnWidth}
                              height={adjustedHeight}
                              onScroll={onScroll}
                              overrideStyle={overrideStyle}
                              cols={cols}
                              overscanColumnCount={overscanColumnCount}
                              width={adjustedWidth}
                              searching={searching}
                              rowCount={rowCount || 1}
                              onCellDoubleClick={onCellDoubleClick}
                              rows={rows}
                              scrollTop={scrollTop}
                              estimatedColumnsSize={estimatedColumnsSize}
                              columnCount={columnCount}
                              scrollLeft={scrollLeft}
                              onScrollbarPresenceChange={this._onScrollbarPresenceChange}
                              selectableRows={selectableRows}
                              selectedRows={this.state.selectedRows}
                              hoveredCell={hoveredCell}
                              onCellEnter={this._onCellEnter}
                              onCellLeave={this._onCellLeave}
                              onToggleRow={this._onToggleRow}
                              isVerticalScrollbarDisplayed={this.state.isVerticalScrollbarDisplayed}
                              cellContextMenu={cellContextMenu}
                              onSectionRendered={this._onSectionRendered}
                            />
                          </div>
                        </div>
                      )
                    }
                  </ScrollSync>
                </div>
              );
            }
          }
        </ContainerDimensions>
      </ErrorBoundary>
    );
  }
}

export default VirtualizedTableView;
